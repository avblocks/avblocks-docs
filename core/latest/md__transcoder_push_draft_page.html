<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>AVBlocks for C++: Copy from this page to TranscoderPush.page.md as you document each of the formats. Start with the video formats first, then audio, and last work on the image formats.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra-doxygen.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-226295-13']);
    _gaq.push(['_trackPageview']);
    (function () {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AVBlocks for C++
   &#160;<span id="projectnumber">3.0</span>
   </div>
   <div id="projectbrief">Audio and Video Software Development Kit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__transcoder_push_draft_page.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Copy from this page to TranscoderPush.page.md as you document each of the formats. Start with the video formats first, then audio, and last work on the image formats. </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr  />
<h1><a class="anchor" id="using_transcoder_push_bmp"></a>
BMP</h1>
<h2><a class="anchor" id="autotoc_md12"></a>
1</h2>
<p>To be able to use Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::BMP);</div>
</div><!-- fragment --><p> And the <code>VideoStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">vsi-&gt;setFrameHeight( 640 );</div>
<div class="line">vsi-&gt;setFrameWidth( 360 );</div>
<div class="line">vsi-&gt;setColorFormat(primo::codecs::ColorFormat::BGR24);</div>
<div class="line">vsi-&gt;setStreamType(primo::codecs::StreamType::BMP);</div>
<div class="line">vsi-&gt;setScanType(primo::codecs::ScanType::Progressive);</div>
</div><!-- fragment --><p> Set the <code>VideoStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>VideoStreamInfo</code> correctly or else transcoder Transcoder::open or Transcoder::push will fail. If you do not know them you can search the input data for <b>0x42 0x4D</b> which is the start marker for BMP format and then check in the headers what you need. Here you can find information about bitmap headers <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183391%28v=vs.85%29.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dd183391%28v=vs.85%29.aspx</a></p>
<h2><a class="anchor" id="autotoc_md13"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain the whole image. If the buffer contains more data you can set the offset and the data size.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
6</h2>
<p>After these five steps we are ready to call Transcoder::push method, Transcoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_PNG"></a>
PNG</h1>
<h2><a class="anchor" id="autotoc_md18"></a>
1</h2>
<p>To be able to use transcoder Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::PNG);</div>
</div><!-- fragment --><p> And the <code>VideoStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">vsi-&gt;setFrameHeight( 640 );</div>
<div class="line">vsi-&gt;setFrameWidth( 360 );</div>
<div class="line">vsi-&gt;setStreamType(primo::codecs::StreamType::PNG);</div>
<div class="line">vsi-&gt;setScanType(primo::codecs::ScanType::Progressive);</div>
</div><!-- fragment --><p> Set the <code>VideoStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>VideoStreamInfo</code> correctly or else transcoder Transcoder::open or Transcoder::push will fail. The first eight bytes of a PNG file always contain the following values: <b>0x89 0x50 0x4E 0x47 0x0D 0x0A 0x1A 0x0A</b>. The last four bytes contain the following values: <b>0x49 0x45 0x4E 0x44</b>. For more information see <code>ISO/IEC International Standard 15948</code>.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain the whole image. If the buffer contains more data you can set the offset and the data size.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
6</h2>
<p>After these five steps we are ready to call Transcoder::push method, Transcoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_TIFF"></a>
TIFF</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
1</h2>
<p>To be able to use transcoder Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::TIFF);</div>
</div><!-- fragment --><p> And the <code>VideoStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">vsi-&gt;setFrameHeight( 640 );</div>
<div class="line">vsi-&gt;setFrameWidth( 360 );</div>
<div class="line">vsi-&gt;setStreamType(primo::codecs::StreamType::TIFF);</div>
<div class="line">vsi-&gt;setScanType(primo::codecs::ScanType::Progressive);</div>
</div><!-- fragment --><p> Set the <code>VideoStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>VideoStreamInfo</code> correctly or else transcoder Transcoder::open or Transcoder::push will fail. The first two bytes of a TIFF file contain the following values: <b>0x49 0x49</b> or <b>0x4D 0x4D</b>. The next two bytes are arbitrary number but identify the file as a TIFF. Most common first four bytes are <b>0x49 0x49 0x2A 0x00</b> and <b>0x4D 0x4D 0x00 0x2A</b>. The end of the file is most probably where the IFD tag is 0. For further information see these links <a href="http://paulbourke.net/dataformats/tiff/">http://paulbourke.net/dataformats/tiff/</a> and <a href="http://www.fileformat.info/format/tiff/egff.htm">http://www.fileformat.info/format/tiff/egff.htm</a></p>
<h2><a class="anchor" id="autotoc_md25"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain the whole image. If the buffer contains more data you can set the offset and the data size.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
6</h2>
<p>After these five steps we are ready to call Transcoder::push method, Transcoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_GIF"></a>
GIF</h1>
<h2><a class="anchor" id="autotoc_md30"></a>
1</h2>
<p>To be able to use transcoder Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::GIF);</div>
</div><!-- fragment --><p> And the <code>VideoStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">vsi-&gt;setFrameHeight( 640 );</div>
<div class="line">vsi-&gt;setFrameWidth( 360 );</div>
<div class="line">vsi-&gt;setStreamType(primo::codecs::StreamType::GIF);</div>
<div class="line">vsi-&gt;setScanType(primo::codecs::ScanType::Progressive);</div>
</div><!-- fragment --><p> Set the <code>VideoStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>VideoStreamInfo</code> correctly or else transcoder Transcoder::open or Transcoder::push will fail. The first six bytes of a GIF file contain the following values: <b>0x47 0x49 0x46 0x38 0x37 0x61</b> for <code>GIF87a</code> or <b>0x47 0x49 0x46 0x38 0x39 0x61</b> for <code>GIF89a</code>. To see further information about the GIF file structure see <a href="https://en.wikipedia.org/wiki/GIF#Image_coding">https://en.wikipedia.org/wiki/GIF#Image_coding</a></p>
<h2><a class="anchor" id="autotoc_md31"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain the whole image. If the buffer contains more data you can set the offset and the data size.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
6</h2>
<p>After these five steps we are ready to call Transcoder::push method, Transcoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_LPCM"></a>
LPCM</h1>
<h2><a class="anchor" id="autotoc_md36"></a>
1</h2>
<p>To be able to use transcoder Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::LPCM);</div>
</div><!-- fragment --><p> And the <code>AudioStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">asi-&gt;setChannels(2);</div>
<div class="line">asi-&gt;setBitsPerSample(16);</div>
<div class="line">asi-&gt;setSampleRate(48000);</div>
<div class="line">asi-&gt;setStreamType(StreamType::LPCM);</div>
</div><!-- fragment --><p> Set the <code>AudioStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>AudioStreamInfo</code> correctly or else transcoder Transcoder::open or Transcoder::push will fail.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain at least one audio frame. Audio frame is an unit that is calculated in bytes, its value is the number of channels multiplied by the bits per sample.</p>
<h2><a class="anchor" id="autotoc_md41"></a>
6</h2>
<p>After these five steps it is needed to create a loop. In the loop we check if the buffer has the needed data if so we are ready to call Transcoder::push method. The cycle must stop when the push fails or we do not expect more data.</p>
<h2><a class="anchor" id="autotoc_md42"></a>
7</h2>
<p>After using Transcoder::push we need to callTranscoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_ALAW"></a>
ALAW PCM</h1>
<h2><a class="anchor" id="autotoc_md43"></a>
1</h2>
<p>To be able to use transcoder Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::ALAW_PCM);</div>
</div><!-- fragment --><p> And the <code>AudioStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">asi-&gt;setChannels(1);</div>
<div class="line">asi-&gt;setBitsPerSample(8);</div>
<div class="line">asi-&gt;setSampleRate(8000);</div>
<div class="line">asi-&gt;setStreamType(StreamType::ALAW_PCM);</div>
</div><!-- fragment --><p> Set the <code>AudioStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>AudioStreamInfo</code> exactly like that because alaw has no other settings.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md46"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain at least one audio frame. Audio frame is an unit that is calculated in bytes, its value is the number of channels multiplied by the bits per sample.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
6</h2>
<p>After these five steps it is needed to create a loop. In the loop we check if the buffer has the needed data if so we are ready to call Transcoder::push method. The cycle must stop when the Transcoder::push fails or we do not expect more data.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
7</h2>
<p>After using Transcoder::push we need to callTranscoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_MULAW"></a>
MULAW PCM</h1>
<h2><a class="anchor" id="autotoc_md50"></a>
1</h2>
<p>To be able to use transcoder Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::MULAW_PCM);</div>
</div><!-- fragment --><p> And the <code>AudioStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">asi-&gt;setChannels(1);</div>
<div class="line">asi-&gt;setBitsPerSample(8);</div>
<div class="line">asi-&gt;setSampleRate(8000);</div>
<div class="line">asi-&gt;setStreamType(StreamType::MULAW_PCM);</div>
</div><!-- fragment --><p> Set the <code>AudioStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>AudioStreamInfo</code> exactly like that because mulaw has no other settings.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md53"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain at least one audio frame. Audio frame is an unit that is calculated in bytes, its value is the number of channels multiplied by the bits per sample.</p>
<h2><a class="anchor" id="autotoc_md55"></a>
6</h2>
<p>After these five steps it is needed to create a loop. In the loop we check if the buffer has the needed data if so we are ready to call Transcoder::push method. The cycle must stop when the Transcoder::push fails or we do not expect more data.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
7</h2>
<p>After using Transcoder::push we need to callTranscoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_G726"></a>
G726 ADPCM</h1>
<h2><a class="anchor" id="autotoc_md57"></a>
1</h2>
<p>To be able to use transcoder Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::G726_ADPCM);</div>
</div><!-- fragment --><p> And the <code>AudioStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">asi-&gt;setStreamType(StreamType::G726_ADPCM);</div>
<div class="line">asi-&gt;setStreamSubType(StreamSubType::G726_PACKED_RFC3551);</div>
<div class="line">asi-&gt;setChannels(1);</div>
<div class="line">asi-&gt;setSampleRate(8000);</div>
<div class="line">asi-&gt;setBitrate(64000);</div>
</div><!-- fragment --><p> Set the <code>AudioStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>AudioStreamInfo</code> exactly like that because mulaw has no other settings. There are two sub types <code>G726_PACKED_RFC3551</code> and <code>G726_PACKED_AAL2</code>. You can see other possible settings in <a href="https://en.wikipedia.org/wiki/G.726">https://en.wikipedia.org/wiki/G.726</a></p>
<h2><a class="anchor" id="autotoc_md58"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md61"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain at least one audio frame. Audio frame is an unit that is calculated in bytes, its value is the number of channels multiplied by the bits per sample. For G726_ADPCM the audio frame is up to 1 byte.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
6</h2>
<p>After these five steps it is needed to create a loop. In the loop we check if the buffer has the needed data if so we are ready to call Transcoder::push method. The cycle must stop when the Transcoder::push fails or we do not expect more data.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
7</h2>
<p>After using Transcoder::push we need to callTranscoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_UncompressedVideo"></a>
Uncompressed video</h1>
<h2><a class="anchor" id="autotoc_md64"></a>
1</h2>
<p>To be able to use transcoder Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::UncompressedVideo);</div>
</div><!-- fragment --><p> And the <code>VideoStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">vsi-&gt;setFrameRate(30);</div>
<div class="line">vsi-&gt;setFrameWidth(352);</div>
<div class="line">vsi-&gt;setFrameHeight(288);</div>
<div class="line">vsi-&gt;setColorFormat(ColorFormat::YUV420);</div>
<div class="line">vsi-&gt;setScanType(ScanType::Progressive);</div>
<div class="line">vsi-&gt;setStreamType(StreamType::UncompressedVideo);</div>
</div><!-- fragment --><p> Set the <code>VideoStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>VideoStreamInfo</code> correctly.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain only one video frame. One video frame is equal to: </p><pre class="fragment">frameSize = frameHeight * frameWidth * bitsPerPixel
</pre> <h2><a class="anchor" id="autotoc_md69"></a>
6</h2>
<p>After these five steps it is needed to create a loop. In the loop we check if the buffer has the needed data if so we are ready to call Transcoder::push method. The cycle must stop when the Transcoder::push fails or we do not expect more data.</p>
<h2><a class="anchor" id="autotoc_md70"></a>
7</h2>
<p>After using Transcoder::push we need to callTranscoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_MPEG1_Video"></a>
MPEG1 video</h1>
<h2><a class="anchor" id="autotoc_md71"></a>
1</h2>
<p>To be able to use transcoder Transcoder::push first we need to set the transcoder's sockets. The input socket should be set correctly. Here is what the input socket should look like: </p><div class="fragment"><div class="line">socket-&gt;setFile(NULL);</div>
<div class="line">socket-&gt;setStream(NULL);</div>
<div class="line">socket-&gt;setStreamType(StreamType::MPEG1_Video);</div>
</div><!-- fragment --><p> And the <code>VideoStreamInfo</code> for the MediaPin should be set like this: </p><div class="fragment"><div class="line">vsi-&gt;setFrameRate(29.97);</div>
<div class="line">vsi-&gt;setStreamType(StreamType::MPEG1_Video);</div>
<div class="line">vsi-&gt;setColorFormat(ColorFormat::YUV420);</div>
<div class="line">vsi-&gt;setScanType(ScanType::Progressive);</div>
<div class="line">vsi-&gt;setFrameWidth(240);</div>
<div class="line">vsi-&gt;setFrameHeight(180);</div>
</div><!-- fragment --><p> Set the <code>VideoStreamInfo</code> to the pin and then add the pin to the socket.</p>
<p><b>NOTE</b>: It is very important to set <code>VideoStreamInfo</code> correctly.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
2</h2>
<p>The output socket settings depends on the desired output.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
3</h2>
<p>Add the input and output socket to the transcoder.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
4</h2>
<p>Call transcoder Transcoder::open.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
5</h2>
<p>Here we need to create MediaSample and primo::codecs::MediaBuffer "MediaBuffer". The buffer should contain a picture. A picture is I P or B. Every picture start with <b>0x00 0x00 0x01 0x00</b>.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
6</h2>
<p>After these five steps it is needed to create a loop. In the loop we check if the buffer has the needed data if so we are ready to call Transcoder::push method. The cycle must stop when the Transcoder::push fails or we do not expect more data.</p>
<h2><a class="anchor" id="autotoc_md77"></a>
7</h2>
<p>After using Transcoder::push we need to callTranscoder::flush method. And the last method to call is transcoder Transcoder::close.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_MPEG2_Video"></a>
MPEG2 video</h1>
<p>When the input stream type is StreamType::MPEG2_Video then the MediaSample buffer must contains one video frame.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_MPEG4_Video"></a>
MPEG4 video</h1>
<p>When the input stream type is StreamType::MPEG4_Video then the MediaSample buffer must contains one video frame.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_H264"></a>
H264</h1>
<p>When the input stream type is StreamType::H264 then the MediaSample buffer can be loaded with one video frame or with one NAL Unit.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_MJPEG"></a>
MJPEG</h1>
<p>When the input stream type is StreamType::MJPEG then the MediaSample buffer must contains one video frame.</p>
<p><br  />
 </p>
<h1><a class="anchor" id="push_MPEG_TS"></a>
MPEG TS</h1>
<p>When the input stream type is StreamType::MPEG_TS then the MediaSample buffer can be loaded with one or more bytes. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <a href="http://primosoftware.com" target="_blank">(c) Primo Software. All rights reserved.</a>
    </li>
  </ul>
</div>
</body>
</html>
